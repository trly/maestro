#!/usr/bin/env bash
set -euo pipefail

print_tool_definition() {
	cat <<-'EOF'
		name: bump_version
		description: Bump version numbers across the codebase.
		description: Updates package.json, tauri.conf.json, and Cargo.toml, then prompts to update CHANGELOG and create a commit with tag.
		
		major: boolean? Bump major version (x.0.0)
		minor: boolean? Bump minor version (0.x.0)
		fix: boolean? Bump patch/fix version (0.0.x)
		rc: string? Create release candidate for specified semver (e.g., "0.2.0" becomes "0.2.0-rc.1")
		version: string? Set explicit version number (e.g., "1.2.3"), overrides all other flags
	EOF
}

read_args_and_run() {
	local major minor fix rc version
	local input=$(</dev/stdin)
	
	while IFS=": " read -r name value; do
		if [[ -n "$name" ]]; then
			case "$name" in
				major|minor|fix)
					# Boolean parameters come as "true" or empty
					local "$name"="$value"
					;;
				rc|version)
					# String parameters
					local "$name"="$value"
					;;
			esac
		fi
	done <<<"$input"
	
	# Handle explicit version
	if [[ -n "${version:-}" ]]; then
		update_version_files "$version"
		prompt_agent "$version"
		return
	fi
	
	# Handle RC version
	if [[ -n "${rc:-}" ]]; then
		if [[ ! "$rc" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
			echo "RC version must be a valid semver (e.g., \"0.2.0\"), got: $rc" >&2
			exit 1
		fi
		
		local next_rc
		next_rc=$(get_next_rc_version "$rc")
		update_version_files "$next_rc"
		prompt_agent "$next_rc"
		return
	fi
	
	# Get current version from package.json
	local current_version
	current_version=$(grep -o '"version": *"[^"]*"' package.json | head -1 | cut -d'"' -f4)
	
	# Count flags
	local flag_count=0
	[[ "${major:-}" == "true" ]] && ((flag_count++))
	[[ "${minor:-}" == "true" ]] && ((flag_count++))
	[[ "${fix:-}" == "true" ]] && ((flag_count++))
	
	if [[ $flag_count -eq 0 ]]; then
		echo "You must specify one of: major, minor, fix, rc, or version" >&2
		exit 1
	fi
	
	if [[ $flag_count -gt 1 ]]; then
		echo "Only one of major, minor, or fix can be specified" >&2
		exit 1
	fi
	
	# Calculate new version
	local new_version
	new_version=$(bump_version "$current_version" "${major:-}" "${minor:-}" "${fix:-}")
	
	update_version_files "$new_version"
	prompt_agent "$new_version"
}

bump_version() {
	local current="$1"
	local do_major="$2"
	local do_minor="$3"
	local do_fix="$4"
	
	# Strip any pre-release suffix
	local base="${current%%-*}"
	
	# Parse version components
	local major minor patch
	major=$(echo "$base" | cut -d. -f1)
	minor=$(echo "$base" | cut -d. -f2)
	patch=$(echo "$base" | cut -d. -f3)
	
	if [[ "$do_major" == "true" ]]; then
		echo "$((major + 1)).0.0"
	elif [[ "$do_minor" == "true" ]]; then
		echo "${major}.$((minor + 1)).0"
	elif [[ "$do_fix" == "true" ]]; then
		echo "${major}.${minor}.$((patch + 1))"
	fi
}

get_next_rc_version() {
	local base_version="$1"
	
	# Get all tags matching this base version
	local tags
	tags=$(git tag --list "v${base_version}-rc.*" 2>/dev/null || true)
	
	if [[ -z "$tags" ]]; then
		echo "${base_version}-rc.1"
		return
	fi
	
	# Extract RC numbers and find the highest
	local max_rc=0
	while IFS= read -r tag; do
		if [[ "$tag" =~ v[0-9]+\.[0-9]+\.[0-9]+-rc\.([0-9]+) ]]; then
			local rc_num="${BASH_REMATCH[1]}"
			if [[ $rc_num -gt $max_rc ]]; then
				max_rc=$rc_num
			fi
		fi
	done <<< "$tags"
	
	echo "${base_version}-rc.$((max_rc + 1))"
}

update_version_files() {
	local version="$1"
	
	# Update package.json
	sed -i.bak "s/\"version\": *\"[^\"]*\"/\"version\": \"$version\"/" package.json && rm package.json.bak
	
	# Update tauri.conf.json
	sed -i.bak "s/\"version\": *\"[^\"]*\"/\"version\": \"$version\"/" src-tauri/tauri.conf.json && rm src-tauri/tauri.conf.json.bak
	
	# Update Cargo.toml
	sed -i.bak "s/^version = \".*\"/version = \"$version\"/" src-tauri/Cargo.toml && rm src-tauri/Cargo.toml.bak
	
	# Regenerate Cargo.lock
	(cd src-tauri && cargo update -p maestro) || {
		echo "Warning: Failed to update Cargo.lock, but version files were updated" >&2
	}
	
	echo "Updated version to $version in:"
	echo "  - package.json"
	echo "  - src-tauri/tauri.conf.json"
	echo "  - src-tauri/Cargo.toml"
	echo "  - src-tauri/Cargo.lock"
	echo
}

prompt_agent() {
	local version="$1"
	
	cat <<-EOF
		Version files updated to $version.
		
		Now complete these tasks:
		
		1. Update CHANGELOG.md with an entry for version $version
		   - Use git log to find changes since the last version tag
		   - List all fixes, features, and deprecations/removals
		
		2. Commit all changes with message: "bump: version $version"
		   - Include: package.json, src-tauri/tauri.conf.json, src-tauri/Cargo.toml, src-tauri/Cargo.lock, and CHANGELOG.md
		
		3. Create lightweight tag: v$version
		
		IMPORTANT: Do NOT push commits or tags - leave them local for review.
		
		Note: The Homebrew tap (trly/homebrew-maestro) will be automatically updated by the release workflow.
	EOF
}

main() {
	case "${TOOLBOX_ACTION:-${1:-describe}}" in
	describe) print_tool_definition ;;
	execute) read_args_and_run ;;
	*)
		printf "Unknown action: %s\n" "${TOOLBOX_ACTION:-$1}" >&2
		exit 1
		;;
	esac
}

main "$@"
