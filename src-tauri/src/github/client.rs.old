use anyhow::Result;
use crate::types::CiStatus;
use serde::Deserialize;

#[derive(Clone)]
pub struct GitHubClient {
	octocrab: octocrab::Octocrab,
}

#[derive(Debug, Deserialize)]
struct WorkflowRunsResponse {
	total_count: u32,
	workflow_runs: Vec<WorkflowRun>,
}

#[derive(Debug, Deserialize)]
struct WorkflowRun {
	status: String,
	conclusion: Option<String>,
}

impl GitHubClient {
	pub fn new(token: String) -> Result<Self> {
		let octocrab = octocrab::Octocrab::builder()
			.personal_token(token)
			.build()?;
		
		Ok(Self { octocrab })
	}

	/// Get CI status for a commit by checking GitHub Actions workflow runs
	/// Returns:
	/// - Skipped: No workflows configured for this branch
	/// - Pending: Workflows exist but none triggered yet OR workflows still running
	/// - Success: All workflows passed
	/// - Failure: At least one workflow failed
	pub async fn get_ci_status(&self, owner: &str, repo: &str, sha: &str, branch: &str) -> Result<(CiStatus, String)> {
		let url = format!("https://github.com/{}/{}/commit/{}/checks", owner, repo, sha);
		
		log::info!("Fetching CI status for {}/{} @ {} (branch: {})", owner, repo, sha, branch);
		
		// Use octocrab's raw API method to get workflow runs by commit SHA
		let route = format!("/repos/{}/{}/actions/runs?head_sha={}", owner, repo, sha);
		let workflow_runs: WorkflowRunsResponse = self.octocrab
			.get(route, None::<&()>)
			.await?;

		log::info!("Found {} workflow runs for commit {}", workflow_runs.total_count, sha);

		// If no workflow runs found, check if any workflows would trigger for this branch
		if workflow_runs.total_count == 0 {
			// Check if the repo has any workflows that would trigger for this branch
			let has_workflows = self.has_workflows(owner, repo, branch).await?;
			log::info!("Repository has workflows that would trigger for branch {}: {}", branch, has_workflows);
			if !has_workflows {
				log::info!("No workflows would trigger for this branch, returning Skipped");
				return Ok((CiStatus::Skipped, url));
			}
			// Workflows exist but not triggered yet
			log::info!("Workflows exist but not triggered yet, returning Pending");
			return Ok((CiStatus::Pending, url));
		}

		let mut has_pending = false;
		let mut has_failure = false;

		for run in &workflow_runs.workflow_runs {
			match run.status.as_str() {
				"queued" | "in_progress" | "waiting" | "requested" => {
					has_pending = true;
				}
				"completed" => {
					// Check conclusion
					if let Some(conclusion) = &run.conclusion {
						match conclusion.as_str() {
							"success" => {
								// This run passed, continue checking others
							}
							"failure" | "cancelled" | "timed_out" | "action_required" => {
								has_failure = true;
							}
							_ => {
								// Treat unknown conclusions as failure
								has_failure = true;
							}
						}
					} else {
						// Completed but no conclusion? Treat as pending
						has_pending = true;
					}
				}
				_ => {
					// Unknown status, treat as pending
					has_pending = true;
				}
			}
		}

		// Determine overall status: any failure means overall failure
		let status = if has_failure {
			CiStatus::Failure
		} else if has_pending {
			CiStatus::Pending
		} else {
			CiStatus::Success
		};

		Ok((status, url))
	}

	/// Check if repository has any GitHub Actions workflows that would trigger for the given branch
	async fn has_workflows(&self, owner: &str, repo: &str, branch: &str) -> Result<bool> {
		let route = format!("/repos/{}/{}/actions/workflows", owner, repo);
		
		#[derive(Debug, Deserialize)]
		struct WorkflowsResponse {
			total_count: u32,
			workflows: Vec<Workflow>,
		}
		
		#[derive(Debug, Deserialize)]
		struct Workflow {
			path: String,
		}
		
		match self.octocrab.get::<WorkflowsResponse, _, _>(route.clone(), None::<&()>).await {
			Ok(workflows_response) => {
				log::info!("Repository {}/{} has {} workflows configured", owner, repo, workflows_response.total_count);
				
				if workflows_response.total_count == 0 {
					return Ok(false);
				}
				
				// Check each workflow to see if it would trigger for this branch
				for workflow in workflows_response.workflows {
					if self.workflow_triggers_for_branch(owner, repo, &workflow.path, branch).await? {
						log::info!("Workflow {} would trigger for branch {}", workflow.path, branch);
						return Ok(true);
					}
				}
				
				log::info!("No workflows would trigger for branch {}", branch);
				Ok(false)
			}
			Err(e) => {
				log::warn!("Failed to check workflows for {}/{}: {}. Assuming no workflows.", owner, repo, e);
				Ok(false)
			}
		}
	}
	
	/// Check if a workflow file would trigger for the given branch
	async fn workflow_triggers_for_branch(&self, owner: &str, repo: &str, workflow_path: &str, branch: &str) -> Result<bool> {
		// Get workflow file content
		let route = format!("/repos/{}/{}/contents/{}", owner, repo, workflow_path);
		
		#[derive(Debug, Deserialize)]
		struct ContentResponse {
			content: String,
			encoding: String,
		}
		
		match self.octocrab.get::<ContentResponse, _, _>(route, None::<&()>).await {
			Ok(content_response) => {
				// Decode base64 content
				if content_response.encoding == "base64" {
					use base64::{Engine as _, engine::general_purpose};
					if let Ok(decoded) = general_purpose::STANDARD.decode(&content_response.content.replace('\n', "")) {
						if let Ok(yaml_content) = String::from_utf8(decoded) {
							return Ok(self.yaml_triggers_for_branch(&yaml_content, branch));
						}
					}
				}
				Ok(false)
			}
			Err(e) => {
				log::warn!("Failed to fetch workflow file {}: {}. Assuming it doesn't trigger.", workflow_path, e);
				Ok(false)
			}
		}
	}
	
	/// Parse workflow YAML to check if it triggers for the given branch
	fn yaml_triggers_for_branch(&self, yaml_content: &str, branch: &str) -> bool {
		// Parse YAML to check trigger conditions
		// Look for:
		// on:
		//   push:
		//     branches: [...]
		
		use serde_yaml::Value;
		
		let yaml: Value = match serde_yaml::from_str(yaml_content) {
			Ok(v) => v,
			Err(e) => {
				log::warn!("Failed to parse workflow YAML: {}", e);
				return false;
			}
		};
		
		// Get the "on" field
		let on_field = yaml.get("on");
		
		if let Some(on_value) = on_field {
			// Check if it's a simple string (e.g., on: push)
			if let Some(on_str) = on_value.as_str() {
				// If just "on: push", it triggers for all branches
				return on_str == "push" || on_str == "[push, pull_request]";
			}
			
			// Check if it's an object with push configuration
			if let Some(on_obj) = on_value.as_mapping() {
				if let Some(push_value) = on_obj.get(&Value::String("push".to_string())) {
					// If push is null or empty, triggers for all branches
					if push_value.is_null() {
						return true;
					}
					
					// Check for branches filter
					if let Some(push_obj) = push_value.as_mapping() {
						if let Some(branches_value) = push_obj.get(&Value::String("branches".to_string())) {
							// If branches is specified, check if our branch matches
							if let Some(branches_array) = branches_value.as_sequence() {
								for branch_pattern in branches_array {
									if let Some(pattern) = branch_pattern.as_str() {
										if self.branch_matches_pattern(branch, pattern) {
											return true;
										}
									}
								}
								// If branches specified but no match, return false
								return false;
							}
						} else {
							// No branches filter, triggers for all branches
							return true;
						}
					} else {
						// push: true or similar, triggers for all branches
						return true;
					}
				}
			}
		}
		
		// Default to false if we couldn't determine
		false
	}
	
	/// Check if a branch name matches a GitHub Actions branch pattern
	fn branch_matches_pattern(&self, branch: &str, pattern: &str) -> bool {
		// Handle wildcards
		if pattern.contains('*') {
			// Simple wildcard matching
			let regex_pattern = pattern
				.replace("**", ".*")  // ** matches anything including /
				.replace('*', "[^/]*");  // * matches anything except /
			
			if let Ok(re) = regex::Regex::new(&format!("^{}$", regex_pattern)) {
				return re.is_match(branch);
			}
		}
		
		// Exact match
		branch == pattern
	}
}
